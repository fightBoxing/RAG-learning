#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
阶段三：检索策略优化
目标：提升检索准确率和召回率
"""

"""
学习目标：
1. 掌握Top-K检索优化方法
2. 实现混合检索（关键词+向量）
3. 掌握查询扩展和改写技术
4. 实现重排序算法
5. 管理上下文窗口

测试标准：
- 检索准确率提升20%
- 召回率提升15%
- 检索响应时间<50ms
- 能处理复杂查询
- 上下文窗口利用率>80%

关键技能：
- 相似度检索优化
- BM25算法
- 查询改写
- 重排序模型
- 上下文构建
- 查询扩展
"""


# ==================== 1. Top-K检索优化 ====================
"""
Top-K检索基础：
- 从向量数据库检索最相似的K个文档
- K的选择：通常5-10个
- 相似度阈值：过滤低质量结果

优化策略：
1. 调整K值
   - 小K（3-5）：精确度高，可能遗漏相关信息
   - 中K（5-10）：平衡选择
   - 大K（10-20）：召回率高，但上下文可能冗余

2. 相似度阈值
   - 设置最小相似度阈值
   - 过滤低质量结果
   - 提高准确性

3. 多样性检索
   - 避免返回过于相似的结果
   - MMR（Maximal Marginal Relevance）算法
   - 在相关性和多样性间平衡

4. 过滤条件
   - 基于元数据过滤
   - 时间范围、来源、类别等
   - 提高精确度

评估指标：
- Precision@K：Top-K结果中相关文档的比例
- Recall@K：相关文档在Top-K中的覆盖率
- MRR（Mean Reciprocal Rank）：第一个相关文档的排名

优化目标：
- Precision@5 > 0.8
- Recall@10 > 0.7
- 查询响应 < 50ms
"""


# ==================== 2. 混合检索 ====================
"""
混合检索原理：
结合多种检索方法的优势
1. 向量检索（语义检索）
2. 关键词检索（BM25）
3. 元数据过滤

混合检索类型：
1. 简单加权融合
   - Score = w1 * vector_score + w2 * bm25_score
   - 权重需要调优

2. 顺序检索
   - 先用BM25快速过滤
   - 再用向量检索精确匹配
   - 平衡速度和准确性

3. 并行检索
   - 同时执行多种检索
   - 融合结果
   - 最大化准确性

BM25算法：
- TF-IDF的改进版本
- 考虑文档长度归一化
- 参数k1和b可调优
- 适用于关键词匹配

混合检索优势：
- 结合语义和关键词
- 提高召回率和精确率
- 更好的鲁棒性
- 适用于复杂查询

实现步骤：
1. 建立向量索引
2. 建立BM25索引
3. 并行检索
4. 结果融合
5. 重排序
"""


# ==================== 3. 查询扩展和改写 ====================
"""
查询扩展（Query Expansion）：
扩展查询以包含更多相关信息

方法1：同义词扩展
- 添加查询词的同义词
- 使用词库或WordNet
- 示例："AI" → "AI, 人工智能, 机器学习"

方法2：相关词扩展
- 从相关文档中提取关键词
- 添加到查询中
- 提高召回率

方法3：多查询生成
- 生成多个变体查询
- 融合检索结果
- 提高覆盖率

查询改写（Query Rewriting）：
优化查询表述，提高检索效果

方法1：LLM改写
- 使用LLM改写查询
- 使查询更清晰、更具体
- 示例："怎么做？" → "如何使用RAG技术？"

方法2：去模糊化
- 消除歧义
- 添加上下文
- 示例："苹果" → "苹果公司" 或 "苹果水果"

方法3：意图识别
- 识别用户真实意图
- 调整查询策略
- 示例："对比" → 需要检索多个相关文档

查询优化流程：
1. 原始查询
2. 查询清理（去除停用词等）
3. 查询扩展（添加相关词）
4. 查询改写（优化表述）
5. 多查询生成
6. 检索
7. 结果融合

效果评估：
- 召回率提升
- 相关性提升
- 用户体验改善
"""


# ==================== 4. 重排序（Reranking） ====================
"""
重排序原理：
对检索结果进行二次排序，提高精确度

为什么需要重排序？
- 初始检索使用快速算法（HNSW）
- 可以使用更复杂但慢的模型
- 显著提升Top-K质量

重排序模型：
1. Cross-Encoder
   - 输入：[查询, 文档]对
   - 输出：相关性分数
   - 模型：ms-marco-MiniLM-L-6-v2
   - 性能：高
   - 速度：慢（需逐对计算）

2. MonoT5
   - 基于T5模型
   - 生成相关性分数
   - 性能：很高
   - 速度：慢

3. Cohere Rerank
   - 商业API
   - 性能：很高
   - 速度：快
   - 成本：付费

4. ColBERT
   - Late Interaction架构
   - 性能：很高
   - 速度：中

重排序流程：
1. 初始检索（Top-100）
2. 重排序模型打分
3. 重新排序
4. 返回Top-K

优化策略：
1. 两阶段检索
   - 第一阶段：快速检索（Top-100）
   - 第二阶段：重排序（Top-20）

2. 批量处理
   - 批量计算相关性分数
   - 提高效率

3. 缓存
   - 缓存查询结果
   - 避免重复计算

效果提升：
- Precision@K提升10-20%
- Recall@K提升5-10%
- 用户满意度提升

成本考虑：
- 计算成本增加
- 延迟增加
- 权衡质量和速度
"""


# ==================== 5. 上下文窗口管理 ====================
"""
上下文窗口限制：
- LLM上下文窗口有限（4K-128K tokens）
- 需要有效利用有限空间
- 避免信息过载

上下文构建策略：
1. 选择性包含
   - 只包含最相关的文档
   - 基于相似度分数
   - 控制文档数量

2. 文档压缩
   - 提取关键句子
   - 摘要生成
   - 保留核心信息

3. 智能排序
   - 按相关性排序
   - 优先显示最相关信息
   - 提高信息密度

4. 动态窗口
   - 根据查询复杂度调整
   - 简单查询：少文档
   - 复杂查询：多文档

5. 信息去重
   - 去除重复信息
   - 合并相似内容
   - 节省空间

上下文模板设计：
```
Based on the following information:

{context_1}
{context_2}
...

Question: {question}

Answer:
```

优化技巧：
1. 使用清晰的分隔符
2. 提供文档来源
3. 控制上下文长度
4. 优化文档顺序
5. 添加相关元数据

评估指标：
- 上下文利用率（实际使用空间/总空间）
- 信息密度（有用信息/总信息）
- 答案相关性
- Token使用效率

目标：
- 上下文利用率 > 80%
- Token使用效率 > 70%
- 答案相关性 > 85%
"""


# ==================== 6. 实践任务清单 ====================
"""
基础任务：
□ 3.1 实现基础Top-K检索
□ 3.2 实现相似度阈值过滤
□ 3.3 实现MMR多样性检索
□ 3.4 实现BM25算法
□ 3.5 实现混合检索
□ 3.6 实现查询扩展
□ 3.7 实现查询改写
□ 3.8 实现多查询生成
□ 3.9 集成Cross-Encoder重排序
□ 3.10 实现两阶段检索
□ 3.11 实现上下文构建
□ 3.12 实现文档压缩
□ 3.13 实现上下文压缩
□ 3.14 优化上下文模板

进阶任务：
□ 3.15 实现动态Top-K
□ 3.16 实现动态上下文窗口
□ 3.17 实现元数据过滤
□ 3.18 实现结果融合策略
□ 3.19 实现缓存机制
□ 3.20 性能测试和优化

测试验证：
□ 3.21 检索准确率提升20%
□ 3.22 召回率提升15%
□ 3.23 响应时间<50ms
□ 3.24 上下文利用率>80%
□ 3.25 能处理复杂查询

参考资料：
- LangChain检索: https://python.langchain.com/docs/modules/data_connection/retrievers/
- BM25算法: https://en.wikipedia.org/wiki/Okapi_BM25
- Cross-Encoder: https://www.sbert.net/examples/applications/retrieval/README.html
- Rerankers: https://huggingface.co/models?pipeline_tag=reranking
"""

print("阶段三：检索策略优化")
print("=" * 60)
print("\n学习目标：")
print("1. 掌握Top-K检索优化")
print("2. 实现混合检索")
print("3. 掌握查询扩展和改写")
print("4. 实现重排序")
print("5. 管理上下文窗口")

print("\n关键技术：")
print("- Top-K检索")
print("- BM25算法")
print("- 混合检索")
print("- 查询扩展")
print("- 重排序")
print("- 上下文管理")

print("\n核心指标：")
print("- 检索准确率（Precision@K）")
print("- 召回率（Recall@K）")
print("- 响应时间")
print("- 上下文利用率")
